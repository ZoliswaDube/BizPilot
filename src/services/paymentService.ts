// Payment Service - Stripe Integration
import { supabase } from '../lib/supabase'
import type {
  Payment,
  PaymentInsert,
  CreatePaymentRequest,
  RefundPaymentRequest,
  StripePaymentIntent,
  ProcessPaymentRequest
} from '../types/payments'

// Note: Stripe SDK will be loaded dynamically or via script tag
// For production, install: npm install @stripe/stripe-js

class PaymentService {
  private stripePublicKey: string | null = null
  private stripe: any = null

  constructor() {
    this.stripePublicKey = import.meta.env.VITE_STRIPE_PUBLIC_KEY || null
  }

  /**
   * Initialize Stripe
   */
  async initializeStripe() {
    if (this.stripe) return this.stripe

    if (!this.stripePublicKey) {
      console.warn('Stripe public key not configured')
      return null
    }

    try {
      // Dynamically import Stripe
      const { loadStripe } = await import('@stripe/stripe-js')
      this.stripe = await loadStripe(this.stripePublicKey)
      return this.stripe
    } catch (error) {
      console.error('Failed to load Stripe:', error)
      return null
    }
  }

  /**
   * Create a payment intent (South African market - ZAR)
   */
  async createPaymentIntent(
    businessId: string,
    amount: number,
    currency: string = 'ZAR',
    metadata: Record<string, any> = {}
  ): Promise<StripePaymentIntent | null> {
    try {
      // Call your backend/edge function to create payment intent
      const { data, error } = await supabase.functions.invoke('create-payment-intent', {
        body: {
          business_id: businessId,
          amount: Math.round(amount * 100), // Convert to cents
          currency: currency.toLowerCase(),
          metadata
        }
      })

      if (error) throw error
      return data as StripePaymentIntent
    } catch (error) {
      console.error('Error creating payment intent:', error)
      return null
    }
  }

  /**
   * Process a payment
   */
  async processPayment(
    businessId: string,
    request: ProcessPaymentRequest
  ): Promise<Payment | null> {
    try {
      const stripe = await this.initializeStripe()
      if (!stripe) {
        throw new Error('Stripe not initialized')
      }

      // Create payment intent
      const paymentIntent = await this.createPaymentIntent(
        businessId,
        request.amount,
        request.currency,
        { description: request.description }
      )

      if (!paymentIntent) {
        throw new Error('Failed to create payment intent')
      }

      // Confirm payment
      const { error: confirmError, paymentIntent: confirmedIntent } = await stripe.confirmCardPayment(
        paymentIntent.client_secret,
        {
          payment_method: request.payment_method_id,
        }
      )

      if (confirmError) {
        throw new Error(confirmError.message)
      }

      // Save payment to database
      const paymentData: PaymentInsert = {
        business_id: businessId,
        amount: request.amount,
        currency: request.currency || 'USD',
        status: 'succeeded',
        provider: 'stripe',
        provider_payment_id: confirmedIntent.id,
        payment_method_id: request.payment_method_id,
        description: request.description,
        paid_at: new Date().toISOString(),
        payment_number: '', // Will be generated by database
        refund_amount: 0
      }

      const { data, error } = await supabase
        .from('payments')
        .insert(paymentData)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error processing payment:', error)
      return null
    }
  }

  /**
   * Create a payment record (for manual/offline payments)
   */
  async createPaymentRecord(
    businessId: string,
    request: CreatePaymentRequest
  ): Promise<Payment | null> {
    try {
      // Generate payment number
      const { data: paymentNumber } = await supabase
        .rpc('generate_payment_number', { business_id_param: businessId })

      if (!paymentNumber) {
        throw new Error('Failed to generate payment number')
      }

      const paymentData: PaymentInsert = {
        business_id: businessId,
        order_id: request.order_id,
        invoice_id: request.invoice_id,
        payment_method_id: request.payment_method_id,
        payment_number: paymentNumber,
        amount: request.amount,
        currency: request.currency || 'USD',
        status: 'succeeded',
        provider: request.provider || 'manual',
        provider_payment_id: request.metadata?.provider_payment_id,
        description: request.description,
        metadata: request.metadata,
        paid_at: new Date().toISOString(),
        refund_amount: 0
      }

      const { data, error } = await supabase
        .from('payments')
        .insert(paymentData)
        .select()
        .single()

      if (error) throw error

      // Update invoice if provided
      if (request.invoice_id) {
        await this.updateInvoicePaymentStatus(request.invoice_id)
      }

      return data
    } catch (error) {
      console.error('Error creating payment record:', error)
      return null
    }
  }

  /**
   * Refund a payment
   */
  async refundPayment(request: RefundPaymentRequest): Promise<Payment | null> {
    try {
      // Get original payment
      const { data: payment, error: fetchError } = await supabase
        .from('payments')
        .select('*')
        .eq('id', request.payment_id)
        .single()

      if (fetchError) throw fetchError

      if (payment.status !== 'succeeded') {
        throw new Error('Only succeeded payments can be refunded')
      }

      const refundAmount = request.amount || payment.amount

      if (refundAmount > (payment.amount - payment.refund_amount)) {
        throw new Error('Refund amount exceeds available amount')
      }

      // Process refund with Stripe if it's a Stripe payment
      if (payment.provider === 'stripe' && payment.provider_payment_id) {
        const { error: refundError } = await supabase.functions.invoke('refund-payment', {
          body: {
            payment_intent_id: payment.provider_payment_id,
            amount: Math.round(refundAmount * 100), // Convert to cents
            reason: request.reason
          }
        })

        if (refundError) throw refundError
      }

      // Update payment record
      const newRefundAmount = payment.refund_amount + refundAmount
      const newStatus = newRefundAmount >= payment.amount ? 'refunded' : 'succeeded'

      const { data, error } = await supabase
        .from('payments')
        .update({
          refund_amount: newRefundAmount,
          status: newStatus,
          refunded_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', request.payment_id)
        .select()
        .single()

      if (error) throw error

      // Create transaction record
      await supabase
        .from('payment_transactions')
        .insert({
          payment_id: request.payment_id,
          type: 'refund',
          amount: refundAmount,
          status: 'succeeded'
        })

      // Update invoice if linked
      if (payment.invoice_id) {
        await this.updateInvoicePaymentStatus(payment.invoice_id)
      }

      return data
    } catch (error) {
      console.error('Error refunding payment:', error)
      return null
    }
  }

  /**
   * Update invoice payment status after payment/refund
   */
  private async updateInvoicePaymentStatus(invoiceId: string): Promise<void> {
    try {
      // Get all payments for this invoice
      const { data: payments } = await supabase
        .from('payments')
        .select('amount, refund_amount, status')
        .eq('invoice_id', invoiceId)
        .eq('status', 'succeeded')

      if (!payments) return

      const totalPaid = payments.reduce((sum, p) => sum + p.amount - p.refund_amount, 0)

      // Get invoice
      const { data: invoice } = await supabase
        .from('invoices')
        .select('total_amount')
        .eq('id', invoiceId)
        .single()

      if (!invoice) return

      const amountDue = invoice.total_amount - totalPaid
      let status: string = invoice.total_amount === totalPaid ? 'paid' : 
                           totalPaid > 0 ? 'viewed' : 'sent'

      // Check if overdue
      const { data: invoiceData } = await supabase
        .from('invoices')
        .select('due_date, status')
        .eq('id', invoiceId)
        .single()

      if (invoiceData && amountDue > 0) {
        const dueDate = new Date(invoiceData.due_date)
        const now = new Date()
        if (now > dueDate && invoiceData.status !== 'paid') {
          status = 'overdue'
        }
      }

      // Update invoice
      await supabase
        .from('invoices')
        .update({
          amount_paid: totalPaid,
          amount_due: amountDue,
          status: status,
          paid_date: totalPaid >= invoice.total_amount ? new Date().toISOString() : null,
          updated_at: new Date().toISOString()
        })
        .eq('id', invoiceId)
    } catch (error) {
      console.error('Error updating invoice payment status:', error)
    }
  }

  /**
   * Get payment by ID
   */
  async getPayment(paymentId: string): Promise<Payment | null> {
    try {
      const { data, error } = await supabase
        .from('payments')
        .select('*')
        .eq('id', paymentId)
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error fetching payment:', error)
      return null
    }
  }

  /**
   * Get payments for a business
   */
  async getPayments(businessId: string, filters?: {
    status?: string[]
    date_from?: string
    date_to?: string
    limit?: number
  }): Promise<Payment[]> {
    try {
      let query = supabase
        .from('payments')
        .select('*')
        .eq('business_id', businessId)
        .order('created_at', { ascending: false })

      if (filters?.status && filters.status.length > 0) {
        query = query.in('status', filters.status)
      }

      if (filters?.date_from) {
        query = query.gte('created_at', filters.date_from)
      }

      if (filters?.date_to) {
        query = query.lte('created_at', filters.date_to)
      }

      if (filters?.limit) {
        query = query.limit(filters.limit)
      }

      const { data, error } = await query

      if (error) throw error
      return data || []
    } catch (error) {
      console.error('Error fetching payments:', error)
      return []
    }
  }
}

export const paymentService = new PaymentService()
